class pair{
   	    int max;
		int min;
		int height;
		boolean isBST;	
		BinaryTreeNode<Integer> node;
}


public class Solution {
	
    private static pair largestBSTSubtreeHelper(BinaryTreeNode<Integer> root)
    {
        // an empty tree is always a BST
        if(root==null)
        {
          pair output=new pair();
			 output.max=Integer.MIN_VALUE;
			 output.min=Integer.MAX_VALUE;
			 output.height=0;
			 output.isBST=true;
			 output.node=null;
			 return output;  
        }
        
        if(root==null) {
			 pair output=new pair();
			 output.max=Integer.MIN_VALUE;
			 output.min=Integer.MAX_VALUE;
			 output.height=0;
			 output.isBST=true;
			 output.node=null;
			 return output;
		 }
		 
		 pair lans=largestBSTSubtreeHelper(root.left);
		 pair rans=largestBSTSubtreeHelper(root.right);
		 
		 pair ans=new pair();
		 ans.min=Math.min(root.data, Math.min(lans.min, rans.min));
		 ans.max=Math.max(root.data, Math.max(lans.max, rans.max)); 
		 ans.isBST=(root.data>lans.max && root.data<rans.min && lans.isBST && rans.isBST);
		
		 if(ans.isBST) {
			 ans.node=root;
			 ans.height= Math.max(lans.height, rans.height) + 1;
		 }else if(lans.height>rans.height) {
			 ans.node=lans.node;
			 ans.height=lans.height;
		 }else {
			 ans.node=rans.node;
			 ans.height=rans.height;
		 }
		 return ans;
        
        
    }
	
	public static int largestBSTSubtree(BinaryTreeNode<Integer> root) {
		// Write your code here
        return largestBSTSubtreeHelper(root).height;
	}

}
